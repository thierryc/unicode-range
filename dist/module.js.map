{"mappings":"AAAA;;;;;;;CAOC,GAEM,SAAS,0CAAM,KAAa,EAAE,GAAW;IAC5C,OAAO,MAAM,KAAK;QAAE,QAAQ,MAAM,QAAQ;IAAE,GAAG,CAAC,GAAG,QAAU,QAAQ;AACzE;AAEO,SAAS,0CAAc,GAAa;IACvC,MAAM,SAAwC,EAAE;IAChD,IAAI,QAAQ,GAAG,CAAC,EAAE;IAClB,IAAI,MAAM,GAAG,CAAC,EAAE;IAEhB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC5B,IAAI,GAAG,CAAC,EAAE,KAAK,MAAM,GACjB,MAAM,GAAG,CAAC,EAAE;SACT;QACH,IAAI,UAAU,KACV,OAAO,KAAK;aAEZ,OAAO,KAAK;YAAC;YAAO;SAAI;QAE5B,QAAQ,MAAM,GAAG,CAAC,EAAE;IACxB;IAGJ,IAAI,UAAU,KACV,OAAO,KAAK;SAEZ,OAAO,KAAK;QAAC;QAAO;KAAI;IAG5B,OAAO;AACX;AAEO,SAAS,0CAAmB,aAA4C;IAC3E,SAAS,MAAM,KAAa;QACxB,OAAO,CAAC,EAAE,EAAE,MAAM,SAAS,IAAI,cAAc,SAAS,GAAG,KAAK,CAAC;IACnE;IACA,OAAO,cAAc,IAAI,CAAA;QACrB,IAAI,MAAM,QAAQ,OACd,OAAO;YAAC,MAAM,IAAI,CAAC,EAAE;YAAG,MAAM,IAAI,CAAC,EAAE;SAAE;aAEvC,OAAO,MAAM;IAErB;AACJ;AAGO,SAAS,0CAAuB,aAA4C;IAC/E,SAAS,UAAU,KAAa,EAAE,SAAiB,IAAI;QACnD,OAAO,CAAC,EAAE,OAAO,EAAE,MAAM,SAAS,IAAI,cAAc,SAAS,GAAG,KAAK,CAAC;IAC1E;IAEA,OAAO,cAAc,IAAI,CAAA;QACrB,IAAI,MAAM,QAAQ,OACd,OAAO,CAAC,EAAE,UAAU,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,UAAU,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC;aAExD,OAAO,UAAU;IAEzB,GAAG,KAAK;AACZ;AAEO,SAAS,0CAA6B,aAAqB;IAC9D,MAAM,SAAS,cAAc,MAAM;IAEnC,SAAS,SAAS,SAAiB,EAAE,IAAY,CAAC;QAC9C,OAAO,YAAY,SAAS,UAAU,MAAM,IAAI,MAAM;IAC1D;IAEA,OAAO,OAAO,IAAI,CAAA;QACd,MAAM,QAAQ,MAAM,MAAM;QAC1B,IAAI,MAAM,WAAW,GACjB,OAAO,SAAS,KAAK,CAAC,EAAE,EAAE;aAE1B,OAAO;YAAC,SAAS,KAAK,CAAC,EAAE,EAAE;YAAI,SAAS,KAAK,CAAC,EAAE;SAAE;IAE1D;AACJ;AAEO,SAAS,0CAAmB,KAAoC;IACnE,MAAM,iBAA2B,EAAE;IAEnC,SAAS,iBAAiB,IAA+B;QACrD,OAAO,MAAM,QAAQ,SAAS,KAAK,WAAW;IAClD;IAEA,MAAM,QAAQ,CAAA;QACV,IAAI,iBAAiB,OACjB,IAAK,IAAI,IAAI,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,EAAE,EAAE,IAChC,eAAe,KAAK;aAGxB,eAAe,KAAK;IAE5B;IAEA,OAAO;AACX;AAEO,SAAS,0CAAqB,MAAM,EAAE,MAAM;IAC/C,OAAO,OAAO,OAAO,CAAA,QAAS,OAAO,SAAS;AAClD;AAEO,SAAS,0CAAiB,MAAM,EAAE,MAAM;IAC3C,OAAO,OAAO,OAAO,CAAA,QAAS,CAAC,OAAO,SAAS;AACnD","sources":["src/index.ts"],"sourcesContent":["/**\n * @ap.cx/unicode-range\n *\n * @description A collection of utility functions for generating and manipulating Unicode values.\n * @license MIT\n * @author Thierry Charbonnel\n * \n */\n\nexport function range(start: number, end: number): number[] {\n    return Array.from({ length: end - start + 1 }, (_, index) => start + index);\n}\n\nexport function compactRanges(arr: number[]): (number | [number, number])[] {\n    const result: (number | [number, number])[] = [];\n    let start = arr[0];\n    let end = arr[0];\n\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] === end + 1) {\n            end = arr[i];\n        } else {\n            if (start === end) {\n                result.push(start);\n            } else {\n                result.push([start, end]);\n            }\n            start = end = arr[i];\n        }\n    }\n\n    if (start === end) {\n        result.push(start);\n    } else {\n        result.push([start, end]);\n    }\n\n    return result;\n}\n\nexport function convertToHexValues(compactRanges: (number | [number, number])[]): (string | [string, string])[] {\n    function toHex(value: number): string {\n        return `0x${value.toString(16).toUpperCase().padStart(4, '0')}`;\n    }\n    return compactRanges.map(item => {\n        if (Array.isArray(item)) {\n            return [toHex(item[0]), toHex(item[1])];\n        } else {\n            return toHex(item);\n        }\n    });\n}\n\n\nexport function convertToUnicodeString(compactRanges: (number | [number, number])[]): string {\n    function toUnicode(value: number, prefix: string = 'U+'): string {\n        return `${prefix}${value.toString(16).toUpperCase().padStart(4, '0')}`;\n    }\n\n    return compactRanges.map(item => {\n        if (Array.isArray(item)) {\n            return `${toUnicode(item[0])}-${toUnicode(item[1], '')}`;\n        } else {\n            return toUnicode(item);\n        }\n    }).join(', ');\n}\n\nexport function convertStringToCompactRanges(unicodeString: string): (number | [number | undefined, number | undefined] | undefined)[] {\n    const ranges = unicodeString.split(', ');\n\n    function parseHex(hexString: string, s: number = 0): number | undefined {\n        return hexString ? parseInt(hexString.slice(s), 16) : undefined;\n    }\n\n    return ranges.map(range => {\n        const parts = range.split('-');\n        if (parts.length === 1) {\n            return parseHex(parts[0], 2);\n        } else {\n            return [parseHex(parts[0], 2), parseHex(parts[1])];\n        }\n    });\n}\n\nexport function flattenNestedArray(input: (number | [number, number])[]): number[] {\n    const flattenedArray: number[] = [];\n\n    function isArrayWithRange(item: number | [number, number]): item is [number, number] {\n        return Array.isArray(item) && item.length === 2;\n    }\n\n    input.forEach(item => {\n        if (isArrayWithRange(item)) {\n            for (let i = item[0]; i <= item[1]; i++) {\n                flattenedArray.push(i);\n            }\n        } else {\n            flattenedArray.push(item);\n        }\n    });\n\n    return flattenedArray;\n}\n\nexport function getArrayIntersection(array1, array2) {\n    return array1.filter(value => array2.includes(value));\n}\n\nexport function getMissingValues(array1, array2) {\n    return array1.filter(value => !array2.includes(value));\n}\n"],"names":[],"version":3,"file":"module.js.map"}